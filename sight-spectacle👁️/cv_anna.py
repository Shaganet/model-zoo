# -*- coding: utf-8 -*-
"""CV_Anna.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1U4EFOwxaiJw16JsH6qAcbK4s6eiKgD3n
"""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

from google.colab import drive
drive.mount('/content/drive')

import numpy as np
import matplotlib.pyplot as plt
from scipy import ndimage as ndi
from scipy.signal import find_peaks
import pandas as pd
from skimage.color import rgb2gray
from skimage.exposure import histogram, cumulative_distribution
from skimage.util import img_as_ubyte, invert, img_as_float
from skimage.feature import peak_local_max
from skimage.segmentation import watershed, find_boundaries, relabel_sequential, clear_border
from skimage import measure
from skimage import morphology
from skimage import filters
import math
from collections import defaultdict
import plotly
import plotly.express as px
import plotly.graph_objects as go

from sklearn import feature_extraction
from sklearn.cluster import spectral_clustering

import seaborn as sns

TEM_Image = plt.imread('/content/drive/MyDrive/Colab Notebooks/IM0.jpg')
TEM_Image = invert(img_as_ubyte(rgb2gray(TEM_Image)))
plt.imshow(TEM_Image, cmap='gray')

hi_ins, bins = histogram(TEM_Image) #получение гистаграммы
cdf, cdf_bins = cumulative_distribution(TEM_Image)
hi_ins = np.array(hi_ins/hi_ins.max()) #нормирование по самому интенсивному пику
xi_max, peaks_propeties = find_peaks(hi_ins, height=0,  prominence=0, width=4, distance=1) #нахождение пиков и их характеристик
df_peaks = pd.DataFrame(peaks_propeties) #таблица характеристик пиков
df_peaks.insert(0,'x of peaks', xi_max) #добавление столбца с координатой пика x
df_peaks['widths'] = round(df_peaks['widths']).astype(int)
df_peaks['left_ips'] = round(df_peaks['left_ips']).astype(int)
df_peaks['right_ips'] = round(df_peaks['right_ips']).astype(int)
df_peaks['true_left_bases'] = round(((df_peaks['left_bases']-(1-(df_peaks['peak_heights']/df_peaks['prominences']))*(df_peaks['left_ips']-df_peaks['x of peaks']))+df_peaks['left_bases'])/2).astype(int) #поправка

df_peaks



fig = plt.figure()
plt.plot(bins, hi_ins)
plt.scatter(xi_max, df_peaks['peak_heights'],c='black', marker='X')
plt.scatter(df_peaks['left_ips'], hi_ins[df_peaks['left_ips']],c='green', marker='X')
plt.scatter(df_peaks['right_ips'], hi_ins[df_peaks['right_ips']],c='green', marker='X')
plt.scatter(df_peaks['left_bases'], hi_ins[df_peaks['left_bases']],c='red', marker='X')

back_board=((2*(df_peaks['right_ips'][0]-df_peaks['x of peaks'][0])+df_peaks['x of peaks'][0])+df_peaks['left_bases'][1])/2 #точка разделение двух пиков
back = TEM_Image < back_board
TEM_Image_zb = TEM_Image.copy()
TEM_Image_zb[back]=0 #мы до этой границы зануляем, делаем фон полностью черным

#удаляем сначала маленькиие отверстия, потом маленькие объекты, использованное изображение должно быть типом bool, поэтому TEM_Image_zb > 0
#TEM_Image_hz = morphology.remove_small_objects(morphology.remove_small_holes(TEM_Image_zb > 0))
TEM_Image_hz = morphology.convex_hull_object(TEM_Image_zb>0) #превращаем клетки в выпуклые фигуры
TEM_Image_hz = morphology.remove_small_objects(morphology.remove_small_holes(TEM_Image_hz))
print(df_peaks['true_left_bases'][1])
print(df_peaks['left_bases'][1])

fig, ax = plt.subplots(nrows=1, ncols=2)
ax[0].imshow(TEM_Image_zb, cmap='gray')
ax[0].set_title('Background=0')
ax[0].axis('off')
ax[1].imshow(TEM_Image_hz, cmap='gray')
ax[1].set_title('foreground=True')
ax[1].axis('off')

labels=measure.label(TEM_Image_hz) #определяем отдельно стоящие объекты и присваиваем им номер
regions=measure.regionprops(labels) #определяем свойства объектов

fig, ax = plt.subplots()
ax.imshow(TEM_Image_zb, cmap='gray')
ax.imshow(labels, cmap='Paired', alpha=0.7)
ax.set_title('Segmentation Image with labels')
for props in regions:
    y0, x0 = props.centroid #координаты центра объекта
    ax.text(x0, y0, props.label) #пишем номер

df_regions = pd.DataFrame (measure.regionprops_table (labels, intensity_image=TEM_Image_zb, #аналогичная функция regionprops только для таблицы, тут надо указать какие свойства добавить в столбцы
properties=(
    'label',
    'solidity',
    'extent',
    'eccentricity',
    'equivalent_diameter_area',
    'feret_diameter_max',
    'axis_major_length',
    'axis_minor_length',
    'perimeter',
    'area')))

df_regions

fig = px.imshow(TEM_Image_zb, binary_string=True)
fig.update_traces(hoverinfo='skip')  # hover is only for label info

properties = ['area']

# For each label, add a filled scatter trace for its contour,
# and display the properties of the label in the hover of this trace.
for index in range(0, labels.max()):
    label_i = regions[index].label
    contour = measure.find_contours(labels == label_i, 0.5)[0]
    y, x = contour.T
    hoverinfo = ''
    for k in range(len(properties)):
        hoverinfo += f'<b>{properties[k]}: {getattr(regions[index], properties[k]):.4f}</b><br>'
    fig.add_trace(
        go.Scatter(
            x=x,
            y=y,
            name=str(label_i),
            mode='lines',
            fill='toself',
            showlegend=False,
            hovertemplate=hoverinfo,
            hoveron='points+fills',
        )
    )

plotly.io.show(fig)

